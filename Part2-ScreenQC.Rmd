---
title: "Simple qHTS QC"
author: "Rajarshi Guha"
date: "January 13, 2015"
output:
  html_document:
    toc: true
    theme: readable
    number_sections: true
---
```{r global_options, include=FALSE}
library(knitr)
opts_chunk$set(fig.width=12, warning=FALSE, message=FALSE)
```

Since qHTS data is loaded in to the database, we can access plate and curve data directly from R. However, this requires installation of some packages (`ncgchts`, `ncgcmatrix`, `ncgcrnai`) that depend on Oracle - for Windows users getting this working is non-trivial. In addition, it requires you to know some of the internal details of how we manage qHTS data - this may be TMI! Finally, the packages that support qHTS, matrix and RNAi database access are undocumented. More importantly, direct access to the database is deprecated and so may not be available in the future.

If these functionality are of general interest, then we can consider converting to a form suitable for more general use within NCATS.

# Plate level QC

As an example, lets examine plate summaries for a series of screens
```{r}
library(ROracle)
library(ncgchts)
library(ggplot2)
library(reshape2)

con <- get.connection('hts', 'ncgc', 'probedb')
proto.names <- c('s-vhl-UOK102-1',
                 's-vhl-UOK109-1',
                 's-vhl-UOK121-1',
                 's-vhl-UOK121-2')

protos <- lapply(proto.names, function(p) {
  plates <- get.plates(con, p, type.index=0, layer.index=0)
})
```

So at this point we've got a list of plates for each of the four protocols. How many plates does each one have?
```{r}
sapply(protos, length)
```

To work with a plate we'll need to know the layout. For that we can retrieve the plate map that was used when we loaded the data. In this case each protocol used the same plate map, so we just need to pull one
```{r echo=FALSE}
pm <- get.plate.map(con, proto.names[1])
pm[1:10, 1:10]
```

Now we're in a position to start analysing the plates. First, lets quickly plot the plates using the `image` function
```{r}
flip <- function(m) t(m[nrow(m):1, ])

plates <- protos[[1]]
image(plates[[1]]) # plate is flipped
image(flip(plates[[1]])) # plate is right way up

# Now we plot all the plates in a 4x4 grid and remove the x and y axis labels for brevity
par(mfrow=c(4,4), mar=c(1,1,1,1))
junk <- lapply(plates, function(x) image(flip(x), xaxt='n', yaxt='n'))
```

The plates look OK, but we can get a little more quantitative. Lets compare the median value of the positive control (Bortezomib) to the DMSO controls. In addition since column 1 is media only, we'll also look at the median signal from that.
```{r}
get.median.values <- function(m, pm) {
  media.only <- median(m[,1])
  
  pos.control.idx <- which(pm == 'i')
  pos.control <- median(m[pos.control.idx])
  
  neg.control.idx <- which(pm == 'n')
  neg.control <- median(m[neg.control.idx])
  
  return(data.frame(pid=attr(m, "cmpd.plate.id"), 
                    media=media.only, 
                    pos=pos.control, 
                    neg=neg.control))
}

pm <- get.plate.map(con, proto.names[1])
vals <- do.call(rbind, lapply(protos[[1]], get.median.values, pm))
vals
```

So the tabular summary is nice, but it's nicer to look at a picture. What we'd like is a figure that plots each of columns 3, 4 and 5 against `pid`, using different colors to delineate the series. This is easy to do in ggplot, but we need to rearrange the data so that it is in *stacked* form
```{r}
svals <- melt(vals, id.vars='pid')
head(svals)

ggplot(svals, aes(x=pid, y=value, group=variable, colour=variable))+
  geom_point(size=4)+geom_line()+
  xlab("Compound Plate ID")+ylab("Median Well Value")+
  theme(axis.text.x = element_text(angle=45, hjust=1))
```

You could generate one of these plots for each protocol we obtained. But we could also be a little more masochistic and get a *matrix* of plots at one go. 
```{r fig.width=10, fig.height=8}
all.vals <- lapply(protos, function(plates) {
  r <- do.call(rbind, lapply(plates, get.median.values, pm))
  r$proto <- attr(plates[[1]], 'protocol')
  return(r)
})
all.vals <- do.call(rbind, all.vals)

stacked <- melt(all.vals, id.vars=c('pid', 'proto'))
ggplot(stacked, aes(x=pid, y=value, group=variable, colour=variable))+
  geom_point(size=4)+geom_line()+
    xlab("Compound Plate ID")+ylab("Median Well Value")+
    theme(axis.text.x = element_text(angle=45, hjust=1))+
    facet_wrap(~ proto, scales='free')
```

# Curve level summaries

We can also access curve data dircetly from R using the `query.protocol` function in the `ncgchts` package. This lets us perform curve level summaries very easily. This allows us to easily summarize a single qHTS screen or efficiently summarize multiple screens (e.g., compute a summary of selectivity versus promiscuity).

## Single protocol summaries

First lets pull in a single protocol and compute a few summaries
```{r}
cdata <- query.protocol(con, proto.names[1], 'activity')
head(cdata)
```
As you can see we get a raw data dump, which should be sufficient to summarize the protocol. Obviously we can get more sophisticated by adding in target information and structures. For now, lets get numerical summaries of potency and MAXR, broken down by curve class, and counts of each curve class.
```{r}
library(dplyr)
cdata %>%
  group_by(CCLASS2) %>%
  summarize(N=n(),
            MedPotency=median(LAC50),
            MedMAXR=median(MAXR)) %>%
  arrange(desc(N))
```

We can also get a simpler summary by using the `CCLASS2` variable to make a categorization - *active*, *inactive*, *inconclusive*. Then we compute a summary similar to the above but across these three classes
```{r}
cdata$klass <-ifelse(cdata$CCLASS2 %in% c(-1.1, -1.2, -2.1, -2.2), 
                      "active",
                      ifelse(cdata$CCLASS2 == 4, 
                             "inactive",
                             "inconclusive"))
cdata %>%
  group_by(klass) %>%
  summarize(N=n(),
            MedPotency=median(LAC50, na.rm=TRUE),
            MedMAXR=median(MAXR, na.rm=TRUE)) %>%
  arrange(desc(N))
```

We can easily convert these data.frames to multi-panel plots (each column vs curve class or klass) by restructering them so that we get a stacked version
```{r fig.width=10}
library(reshape2)

csum <- cdata %>%
  group_by(klass) %>%
  summarize(N=n(),
            MedPotency=median(LAC50, na.rm=TRUE),
            MedMAXR=median(MAXR, na.rm=TRUE)) %>%
  arrange(desc(N))

csum <- melt(as.data.frame(csum), id.vars='klass')
ggplot(csum, aes(x=klass, y=value))+
  geom_bar(stat='identity', fill='beige', colour='black')+
  facet_wrap(~variable, scale='free')
```

## Multi protocol summaries

This isn't a whole lot different from summarizing a single protocol - you just loop over a list of data.frame's performing the same summarization. However, lets look at summarizing compound selectivity (or promiscuity) for a series of cell lines. First we pull in curve data for the 4 cell lines
```{r}
cdatas <- lapply(proto.names, function(p) {
  r <- query.protocol(con, p, 'activity')
  r$proto <- p
  r <- r[order(r$SID),] # so that row i in each data.frame corresponds to the same NCGC ID
  return(r)
})
```

Now, for each protocol, we'll generate a logical vector that indicates whether a compound is active or not. 
```{r}
avecs <- lapply(cdatas, function(cdata) {
  ifelse(cdata$CCLASS2 %in% c(-1.1, -1.2, -2.1), TRUE, FALSE)
})
avecs <- do.call(cbind, avecs)
head(avecs)
```

So each row of `avecs` indicates whether that compound is active or inactive in each of the four protocols. Noting that R internally treats `TRUE` as 1 and `FALSE` as 0, we can sum a vector of logicals, the result of which is the number of `TRUE` values as shown below:
```{r}
l <-c(TRUE, TRUE, FALSE)
sum(l)
```

So if we compute the row sums of `avecs` we'll end up with a vector that contains how many times a compound was active in the four protocols - this can range from 0 (inactive in all screens) to 4 (active in all screens).
```{r}
acounts <- rowSums(avecs)
acounts[1:10]
```

Finally, we can then obtain the counts of each count (!) - i.e., how many compounds have 0, how many have 1 etc. Plotting these counts of counts gives us a simple visual summary of the selectivity vs promiscuity of the MIPE compounds in these protocols
```{r}
freqs <- data.frame(table(acounts))
ggplot(freqs, aes(x=acounts, y=Freq))+
  geom_bar(stat='identity', fill='beige', colour='black')+
  xlab("Number of cell lines active in")+
  ylab("Number of compounds")
```

Having summarized the selectivity, how do get the actual compounds that are say pan-active? We have the vector of counts, so we identify which of the elements are 4. The indices of these elements can be used to index one of the data.frame's that holds the curve data to obtain the NCGC ID's.
```{r}
pan.active.idx <- which(acounts == 4)
pan.active <- cdatas[[1]][pan.active.idx,]
pan.active.sid <- pan.active$SID
```

We could then ask, what is the median potency, MAXR and AUC of the pan actives in each of the four cell lines? 
```{r}
pansum <- lapply(cdatas, function(cdata) {
    s <- subset(cdata, SID %in% pan.active.sid) %>%
      group_by(proto) %>%
      summarize(medPotency = median(LAC50),
                medMAXR = median(MAXR),
                medAUC = median(FAUC))
    return(s)
})
pansum <- do.call(rbind, pansum)
pansum

melt(as.data.frame(pansum), id.vars='proto') %>%
  ggplot(aes(x=proto, y=value))+
  geom_bar(stat='identity', fill='beige', colour='black')+
  facet_wrap(~variable, scale='free')+
  theme(axis.text.x = element_text(angle=45, hjust=1))
```

**CAVEAT** Much of these analyses depend on the fact that a compound has the same NCGC ID (including batch) number across all protocols. If batches change (or worse, if the NCGC ID changes) you can get inaccurate or even wrong results.