---
title: "Statistical Testing"
author: "Rajarshi Guha"
date: "January 13, 2015"
output:
  html_document:
    toc: true
    theme: readable
    number_sections: true
---

Since qHTS data is loaded in to the database, we can access plate and curve data directly from R. However, this requires installation of some packages that depend on Oracle - for Windows users getting this working is non-trivial. In addition, it requires you to know some of the internal details of how manage qHTS data - this may be TMI! More importantly, direct access to the database is deprecated and so may not be available in the future.

As an example, lets examine plate summaries for a series of screens
```{r message=FALSE, warning=FALSE}
library(ROracle)
library(ncgchts)
library(ggplot2)
library(reshape)

con <- get.connection('hts', 'ncgc', 'probedb')
proto.names <- c('s-vhl-UOK102-1',
                 's-vhl-UOK109-1',
                 's-vhl-UOK121-1',
                 's-vhl-UOK121-2')

protos <- lapply(proto.names, function(p) {
  plates <- get.plates(con, p, type.index=0, layer.index=0)
})
```

So at this point we've got a list of plates for each of the four protocols. How many plates does each one have?
```{r}
lapply(protos, length)
```

To work with a plate we'll need to know the layout. For that we can retrieve the plate map that was used when we loaded the data. In this case each protocol used the same plate map, so we just need to pull one
```{r echo=FALSE}
pm <- get.plate.map(con, proto.names[1])
pm[1:10, 1:10]
```

Now we're in a position to start analysing the plates. First, lets quickly plot the plates using the `image` function
```{r collapse=TRUE, fig.width=10}
flip <- function(m) t(m[nrow(m):1, ])

plates <- protos[[1]]
image(plates[[1]]) # plate is flipped
image(flip(plates[[1]])) # plate is right way up

# Now we plot all the plates in a 4x4 grid and remove the x and y axis labels for brevity
par(mfrow=c(4,4), mar=c(1,1,1,1))
junk <- lapply(plates, function(x) image(flip(x), xaxt='n', yaxt='n'))
```

The plates look OK, but we can get a little more quantitative. Lets compare the median value of the positive control (Bortezomib) to the DMSO controls. In addition since column 1 is media only, we'll also look at the median signal from that.
```{r}
get.median.values <- function(m, pm) {
  media.only <- median(m[,1])
  
  pos.control.idx <- which(pm == 'i')
  pos.control <- median(m[pos.control.idx])
  
  neg.control.idx <- which(pm == 'n')
  neg.control <- median(m[neg.control.idx])
  
  return(data.frame(pid=attr(m, "plate.id"), 
                    media=media.only, 
                    pos=pos.control, 
                    neg=neg.control))
}

vals <- do.call(rbind, lapply(protos[[1]], get.median.values, pm))
vals
```

So the tabular summary is nice, but it's nicer to look at a picture. What we'd like is a figure that plots each of columns 3, 4 and 5 against `pid`, using different colors to delineate the series. This is easy to do in ggplot, but we need to rearrange the data so that it is in *stacked* form
```{r}
svals <- melt(vals, id.vars='pid')
head(svals)

ggplot(svals, aes(x=pid, y=value, group=variable, colour=variable))+
  geom_point(size=4)+geom_line()+
  xlab("Assay Plate ID")+ylab("Median Well Value")+
  theme(axis.text.x = element_text(angle=45, hjust=1))
```