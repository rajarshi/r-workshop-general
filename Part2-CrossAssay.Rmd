---
title: "Cross Assay Analyses"
author: "Rajarshi Guha"
date: "January 13, 2015"
output:
  html_document:
    toc: true
    theme: readable
    number_sections: true
---
```{r global_options, include=FALSE}
set.seed(123456)
library(knitr)
opts_chunk$set(fig.width=10, warning=FALSE, message=FALSE)
```

We've already seen how we can summarize multiple assays, which is essentially running the same summarization across each assay. But as we saw, we can also look at multiple assays in aggregate, by looking at selectivity or promiscuity of compounds across those assays.

# Cluster targets based on cell line activity

We can then consider some more sophisticated analyses. For example lets look at clustering targets based on their *cell line profile* as well as cluster cell lines based on target or compound profile. For this analysis I extracted MIPE qHTS data from 8 kidney cancer cell lines. The data is available as as a `list` of `data.frame`s stored in an .Rda file.

```{r}
library(ncgchts)
library(ggplot2)
library(reshape2)
library(dplyr)

load('/ncats/prod/common/R-Workshop/cluscl.Rda')
sapply(dat, function(x) x$proto[1])
```

## Constructing features for each target

There are many ways to approach the clustering. As a first step we can try clustering the targets based on their aggregated cell line characteristics. That is, each target is represented by the median MAXR or LAC50 or efficacy in each cell line. So first, we consider each protocol and compute these median values across each target in that protocol (only considering those targets that have 5 or more compounds associated with them)
```{r}
agg.func <- function(d) {
  ret <- d %>% group_by(gene) %>%
            summarize(n=n(),
              maxr=median(MAXR, na.rm=TRUE),
              lac50=median(LAC50, na.rm=TRUE),
              eff=median(eff, na.rm=TRUE)) %>%
    filter(!is.na(gene) & n >= 5)
  return(as.data.frame(ret))  
}
agg <- lapply(dat, agg.func)
head(agg[[1]])
```

## Visualizing cell line profiles

Now, we've considered all compounds in each protocol, ignoring their curve classes. As a result the median `LAC50` may not be an accurate representation. As a result we'll work with MAXR. First we construct a matrix with the targets in the rows and the median MAXR value for each cell line in the columns
```{r fig.width=12}
tcm.maxr <- do.call(cbind, lapply(agg, function(x) x$maxr))
rownames(tcm.maxr) <- agg[[1]]$gene
```

It turns out that there are 77 targets with more than 5 compounds annotated against them. At this stage it's interesting to visualize the MAXR profile of these targets. One way to do this is to generate a [parallel coordinates](http://en.wikipedia.org/wiki/Parallel_coordinates) plot
```{r}
library(GGally)
pardat <- data.frame(tcm.maxr)
names(pardat) <- sapply(dat, function(x) x$proto[1])
ggparcoord(pardat, columns=1:ncol(tcm.maxr), alphaLines=0.75, scale='robust')+
  xlab("Cell Line")+ylab('Standardized Median MAXR')
```

Each line represents a target and its MAXR profile across the 8 cell lines considered. Overall this suggests that there isn't much (obvious) similarity between the targets across these lines. However, things might be clearer if we could color targets by family or pathway.

## Clustering targets & enrichment analysis
Next, we compute a hierarchical clustering, by passing in a distance matrix (computed using `dist`) to the `hclust` function
```{r}
gene.clust <- hclust(dist(tcm.maxr)) # hclust requires a distance matrix
plot(gene.clust, cex=0.8)
```

Given the clustering we can examine individual clusters in more detail. For example, lets see if there is anything interesting in a GO enrichment analysis of the targets in, say, 5 clusters. First we cut the dendrogram to get 5 clusters. The output of `cutree` is a numeric vector whose $i$'th element indicates the cluster id for that target
```{r}
cut5 <- cutree(gene.clust, k=5)
cut5

table(cut5) # How many targets in each cluster?
```

Next, we construct a function that will compute GO enrichments given a set of target symbols, using the human genome as the background.
```{r}
library(org.Hs.eg.db)
library(GOstats)
mapping <- org.Hs.egSYMBOL2EG
mapped.genes <- mappedkeys(mapping)
xx <- as.list(mapping[mapped.genes]) # all genes in the genome
euni <- as.numeric(unlist(xx))

gosum <- function(syms) {  
    syms <- as.numeric(unlist(xx[syms])) # convert symbols to Entrez Gene IDs
    if (length(syms) == 0) return(NA)    
    params.go <- new("GOHyperGParams",
                     geneIds = syms, universeGeneIds = euni,
                     annotation = 'org.Hs.eg.db',
                     pvalueCutoff = 0.05, ontology = 'BP',
                     conditional = TRUE, testDirection = 'over')
    over.go <- hyperGTest(params.go)
    summary(over.go)
}
 
# For each cluster id, we identify the targets by looking at the names of the elements
clus1.idx <- which(cut5 == 1)
clus1.names <- names(cut5)[clus1.idx]
head(gosum(clus1.names))  
```

Naturally, we can process all clusters at one go and this time we'll just look at the top 5 terms and their GO ID's and p-values. Whether this information is of any use is upto the reader to decide!
```{r}
lapply(1:5, function(clusnum) {
  clus.idx <- which(cut5 == clusnum)
  clus.names <- names(cut5)[clus.idx]
  r <- gosum(clus.names)[1:5, c(1,2,7)]    
  r$ClusId <- clusnum
  return(r)
})
```

# Clustering cell lines

We can look at the data from another angle by clustering the cell lines based on their target profile. Given the `tcm.maxr` matrix, we can transpose it to get a matrix with the cell lines in the rows and the median MAXR for each target in the column. Note that this is an initial analysis - ideally we would try and identify a subset of the 77 targets and perform the clustering with that.
```{r}
ccm.maxr <- t(tcm.maxr)

# Extract cell line names from the protocol name
clnames <- sapply(dat, function(x) x$proto[1])
clnames <- strsplit(clnames, "-")
clnames <- sapply(clnames, function(x) x[3])
rownames(ccm.maxr) <- clnames

cl.clust <- hclust(dist(ccm.maxr))
plot(cl.clust)
```